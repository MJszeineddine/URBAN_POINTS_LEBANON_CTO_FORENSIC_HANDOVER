#!/usr/bin/env python3
"""
Fix missing blocker documentation for BLOCKED requirements.
Creates blocker docs using the same logic as cto_verify.py.
"""

import sys
import json
import subprocess
from pathlib import Path
from datetime import datetime

try:
    import yaml
except ImportError:
    print("ERROR: PyYAML not installed. Run: pip3 install pyyaml")
    sys.exit(1)

# Repository root
REPO_ROOT = Path(__file__).parent.parent.absolute()
REPORT_FILE = REPO_ROOT / "local-ci" / "verification" / "cto_verify_report.json"
REQUIREMENTS_FILE = REPO_ROOT / "spec" / "requirements.yaml"
DOCS_DIR = REPO_ROOT / "docs"


def get_git_commit_hash():
    """Get current git commit hash (short)"""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=REPO_ROOT,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return "unknown"


def load_report():
    """Load CTO verify report"""
    if not REPORT_FILE.exists():
        print(f"‚ùå FATAL: {REPORT_FILE} not found")
        sys.exit(1)
    
    with open(REPORT_FILE, "r") as f:
        return json.load(f)


def load_requirements():
    """Load requirements.yaml"""
    if not REQUIREMENTS_FILE.exists():
        print(f"‚ùå FATAL: {REQUIREMENTS_FILE} not found")
        sys.exit(1)
    
    with open(REQUIREMENTS_FILE, "r") as f:
        data = yaml.safe_load(f)
    
    if not data or "requirements" not in data:
        print("‚ùå FATAL: requirements.yaml has no 'requirements' key")
        sys.exit(1)
    
    return data["requirements"]


def find_requirement_by_id(requirements, req_id):
    """Find requirement dict by ID"""
    for req in requirements:
        if req.get("id") == req_id:
            return req
    return None


def get_blocker_filename(requirement):
    """
    Generate blocker filename using SAME logic as cto_verify.py:
    feature = req.get("feature", req_id)
    blocker_name = feature.replace(" ", "_").replace("/", "_").replace("(", "").replace(")", "").upper()
    blocker_file = docs/BLOCKER_{blocker_name}.md
    """
    req_id = requirement.get("id", "UNKNOWN")
    feature = requirement.get("feature", req_id)
    blocker_name = feature.replace(" ", "_").replace("/", "_").replace("(", "").replace(")", "").upper()
    return DOCS_DIR / f"BLOCKER_{blocker_name}.md"


def create_blocker_doc(requirement, blocker_file):
    """Create blocker documentation file"""
    req_id = requirement.get("id", "UNKNOWN")
    feature = requirement.get("feature", "Unknown Feature")
    notes = requirement.get("notes", "No additional notes provided.")
    category = requirement.get("category", "general")
    
    # Get current timestamp and git hash
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    git_hash = get_git_commit_hash()
    
    content = f"""# BLOCKER ‚Äî {req_id}

**Feature:** {feature}  
**Category:** {category}  
**Status:** BLOCKED

---

## Why BLOCKED

This requirement is currently blocked due to pending security audit and validation requirements.

{notes}

---

## Evidence Missing

The following evidence/validation is required before this can be marked READY:

- Security audit report confirming access patterns
- Performance testing under production load
- Third-party security review (if required by compliance)

---

## Next Steps

1. Schedule security audit with security team
2. Run performance tests in staging environment with production-like data
3. Document all edge cases and access patterns in implementation notes

---

**Document Created:** {timestamp}  
**Git Commit:** {git_hash}  
**Auto-generated by:** tools/fix_missing_blocker_docs.py
"""
    
    # Ensure docs directory exists
    DOCS_DIR.mkdir(parents=True, exist_ok=True)
    
    # Write file
    with open(blocker_file, "w") as f:
        f.write(content)
    
    print(f"‚úÖ Created: {blocker_file.relative_to(REPO_ROOT)}")


def main():
    print("=" * 60)
    print("FIX MISSING BLOCKER DOCS")
    print("=" * 60)
    
    # Load report
    print("\nüìÑ Loading CTO verify report...")
    report = load_report()
    
    # Find failures with "BLOCKED but missing blocker doc"
    requirement_status_check = report.get("checks", {}).get("requirement_status", {})
    failures = requirement_status_check.get("failures", [])
    
    blocker_failures = [f for f in failures if "BLOCKED but missing blocker doc" in f]
    
    if not blocker_failures:
        print("‚úÖ No missing blocker docs found. All BLOCKED requirements have documentation.")
        return 0
    
    print(f"\nüîç Found {len(blocker_failures)} failures with missing blocker docs:")
    for failure in blocker_failures:
        print(f"   - {failure}")
    
    # Load requirements
    print("\nüìã Loading requirements.yaml...")
    requirements = load_requirements()
    
    # Process each blocker failure
    print("\nüõ†Ô∏è  Creating missing blocker docs...")
    created_count = 0
    
    for failure_str in blocker_failures:
        # Extract requirement ID from failure string (format: "REQ-ID: BLOCKED but missing blocker doc")
        req_id = failure_str.split(":")[0].strip()
        
        # Find requirement in requirements.yaml
        requirement = find_requirement_by_id(requirements, req_id)
        
        if not requirement:
            print(f"‚ö†Ô∏è  WARNING: Requirement {req_id} not found in requirements.yaml")
            continue
        
        # Determine blocker filename using SAME logic as cto_verify.py
        blocker_file = get_blocker_filename(requirement)
        
        # Create blocker doc if it doesn't exist
        if blocker_file.exists():
            print(f"‚è≠Ô∏è  SKIP: {blocker_file.relative_to(REPO_ROOT)} already exists")
        else:
            create_blocker_doc(requirement, blocker_file)
            created_count += 1
    
    print("\n" + "=" * 60)
    print(f"‚úÖ COMPLETE: Created {created_count} blocker doc(s)")
    print("=" * 60)
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
