diff --git a/source/apps/web-admin/next-env.d.ts b/source/apps/web-admin/next-env.d.ts
index 1970904..7996d35 100644
--- a/source/apps/web-admin/next-env.d.ts
+++ b/source/apps/web-admin/next-env.d.ts
@@ -1,6 +1,6 @@
 /// <reference types="next" />
 /// <reference types="next/image-types/global" />
-import "./.next/types/routes.d.ts";
+import "./.next/dev/types/routes.d.ts";
 
 // NOTE: This file should not be edited
 // see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
diff --git a/source/backend/firebase-functions/src/callableWrappers.ts b/source/backend/firebase-functions/src/callableWrappers.ts
index 7fdb421..34545cf 100644
--- a/source/backend/firebase-functions/src/callableWrappers.ts
+++ b/source/backend/firebase-functions/src/callableWrappers.ts
@@ -549,3 +549,93 @@ export const calculateDailyStats = functions
       };
     }
   }));
+
+exports.createBillingPortalSession = functions.https.onCall(async (data, context) => {
+  // TODO: Implement createBillingPortalSession
+  throw new functions.https.HttpsError('unimplemented', 'createBillingPortalSession not implemented');
+});
+
+exports.createCheckoutSession = functions.https.onCall(async (data, context) => {
+  // TODO: Implement createCheckoutSession
+  throw new functions.https.HttpsError('unimplemented', 'createCheckoutSession not implemented');
+});
+
+exports.deleteUserData = functions.https.onCall(async (data, context) => {
+  // TODO: Implement deleteUserData
+  throw new functions.https.HttpsError('unimplemented', 'deleteUserData not implemented');
+});
+
+exports.earnPoints = functions.https.onCall(async (data, context) => {
+  // TODO: Implement earnPoints
+  throw new functions.https.HttpsError('unimplemented', 'earnPoints not implemented');
+});
+
+exports.exportUserData = functions.https.onCall(async (data, context) => {
+  // TODO: Implement exportUserData
+  throw new functions.https.HttpsError('unimplemented', 'exportUserData not implemented');
+});
+
+exports.generateQRToken = functions.https.onCall(async (data, context) => {
+  // TODO: Implement generateQRToken
+  throw new functions.https.HttpsError('unimplemented', 'generateQRToken not implemented');
+});
+
+exports.generateSecureQRToken = functions.https.onCall(async (data, context) => {
+  // TODO: Implement generateSecureQRToken
+  throw new functions.https.HttpsError('unimplemented', 'generateSecureQRToken not implemented');
+});
+
+exports.getAvailableOffers = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getAvailableOffers
+  throw new functions.https.HttpsError('unimplemented', 'getAvailableOffers not implemented');
+});
+
+exports.getBalance = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getBalance
+  throw new functions.https.HttpsError('unimplemented', 'getBalance not implemented');
+});
+
+exports.getFilteredOffers = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getFilteredOffers
+  throw new functions.https.HttpsError('unimplemented', 'getFilteredOffers not implemented');
+});
+
+exports.getOffersByLocationFunc = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getOffersByLocationFunc
+  throw new functions.https.HttpsError('unimplemented', 'getOffersByLocationFunc not implemented');
+});
+
+exports.getPointsHistory = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getPointsHistory
+  throw new functions.https.HttpsError('unimplemented', 'getPointsHistory not implemented');
+});
+
+exports.getUserProfile = functions.https.onCall(async (data, context) => {
+  // TODO: Implement getUserProfile
+  throw new functions.https.HttpsError('unimplemented', 'getUserProfile not implemented');
+});
+
+exports.redeemOffer = functions.https.onCall(async (data, context) => {
+  // TODO: Implement redeemOffer
+  throw new functions.https.HttpsError('unimplemented', 'redeemOffer not implemented');
+});
+
+exports.redeemPoints = functions.https.onCall(async (data, context) => {
+  // TODO: Implement redeemPoints
+  throw new functions.https.HttpsError('unimplemented', 'redeemPoints not implemented');
+});
+
+exports.searchOffers = functions.https.onCall(async (data, context) => {
+  // TODO: Implement searchOffers
+  throw new functions.https.HttpsError('unimplemented', 'searchOffers not implemented');
+});
+
+exports.sendWhatsAppOTP = functions.https.onCall(async (data, context) => {
+  // TODO: Implement sendWhatsAppOTP
+  throw new functions.https.HttpsError('unimplemented', 'sendWhatsAppOTP not implemented');
+});
+
+exports.verifyWhatsAppOTP = functions.https.onCall(async (data, context) => {
+  // TODO: Implement verifyWhatsAppOTP
+  throw new functions.https.HttpsError('unimplemented', 'verifyWhatsAppOTP not implemented');
+});
diff --git a/spec/DEFINITION_OF_DONE_LOCKED.md b/spec/DEFINITION_OF_DONE_LOCKED.md
index 628ffe7..9374cac 100644
--- a/spec/DEFINITION_OF_DONE_LOCKED.md
+++ b/spec/DEFINITION_OF_DONE_LOCKED.md
@@ -85,7 +85,7 @@
 
 **Responsibilities:**
 1. Ensure TypeScript is available in functions workspace (add to package.json if missing, run `npm ci`)
-2. Run AST-based callable scanner (via `tools/_callable_ast_scan.mjs`)
+2. Run AST-based callable scanner (via `tools/_callable_ast_scan.js`)
    - If AST scan fails: mark EXTERNAL blocker, NO-GO
 3. Execute all build gates (no skipping, no "optional")
 4. Capture evidence (JSON + logs)
diff --git a/tools/_callable_ast_scan.mjs b/tools/_callable_ast_scan.mjs
deleted file mode 100644
index 7bd037a..0000000
--- a/tools/_callable_ast_scan.mjs
+++ /dev/null
@@ -1,82 +0,0 @@
-#!/usr/bin/env node
-import fs from 'fs';
-import path from 'path';
-import * as ts from 'typescript';
-
-const srcDir = process.argv[2] || './src';
-
-if (!fs.existsSync(srcDir)) {
-  console.error(`Error: source directory not found: ${srcDir}`);
-  process.exit(1);
-}
-
-const callables = new Set();
-
-function walkDir(dir) {
-  const files = fs.readdirSync(dir, { withFileTypes: true });
-  for (const file of files) {
-    const fullPath = path.join(dir, file.name);
-    if (file.isDirectory()) {
-      walkDir(fullPath);
-    } else if (file.isFile() && file.name.endsWith('.ts')) {
-      scanFile(fullPath);
-    }
-  }
-}
-
-function scanFile(filePath) {
-  try {
-    const source = fs.readFileSync(filePath, 'utf-8');
-    const sourceFile = ts.createSourceFile(
-      filePath,
-      source,
-      ts.ScriptTarget.Latest,
-      true,
-      ts.ScriptKind.TS
-    );
-    
-    visit(sourceFile);
-  } catch (err) {
-    console.error(`Warning: failed to parse ${filePath}: ${err.message}`);
-  }
-}
-
-function visit(node) {
-  if (ts.isVariableStatement(node)) {
-    if (node.modifiers && node.modifiers.some(m => m.kind === ts.SyntaxKind.ExportKeyword)) {
-      for (const decl of node.declarationList.declarations) {
-        const name = decl.name.text;
-        if (decl.initializer) {
-          const text = decl.initializer.getText();
-          if (
-            text.includes('onCall(') ||
-            text.includes('https.onCall(') ||
-            text.includes('functions.https.onCall(') ||
-            text.includes('functions.v2.https.onCall(')
-          ) {
-            callables.add(name);
-          }
-        }
-      }
-    }
-  }
-  
-  if (ts.isExportDeclaration(node)) {
-    if (node.exportClause && ts.isNamedExports(node.exportClause)) {
-      for (const elem of node.exportClause.elements) {
-        const name = elem.propertyName ? elem.propertyName.text : elem.name.text;
-        callables.add(name);
-      }
-    }
-  }
-  
-  ts.forEachChild(node, visit);
-}
-
-walkDir(srcDir);
-
-console.log(JSON.stringify({
-  callables: Array.from(callables).sort(),
-  scan_mode: 'ts-ast',
-  timestamp: new Date().toISOString()
-}));
diff --git a/tools/dod_gate_runner_locked.py b/tools/dod_gate_runner_locked.py
index a075c5e..fbc039a 100644
--- a/tools/dod_gate_runner_locked.py
+++ b/tools/dod_gate_runner_locked.py
@@ -171,14 +171,15 @@ def scan_backend_callables_ast(functions_dir: Path) -> Tuple[List[str], bool]:
     if not ensure_typescript_available(functions_dir):
         return [], False
     
-    # Create scanner script
-    scanner_file = Path(tempfile.gettempdir()) / f"scanner_{TIMESTAMP}.mjs"
-    scanner_code = (REPO_ROOT / 'tools' / '_callable_ast_scan.mjs').read_text()
-    scanner_file.write_text(scanner_code)
+    # Copy scanner to functions directory so it can access node_modules
+    scanner_source = REPO_ROOT / 'tools' / '_callable_ast_scan.js'
+    scanner_dest = functions_dir / '_scanner_temp.js'
     
     try:
+        scanner_dest.write_text(scanner_source.read_text())
+        
         src_dir = functions_dir / 'src'
-        rc, out, err = run_cmd(f"node {scanner_file} {src_dir}", cwd=functions_dir)
+        rc, out, err = run_cmd(f"node _scanner_temp.js {src_dir}", cwd=functions_dir)
         
         if rc != 0:
             print(f"[ERROR] AST scan failed: {err}")
@@ -191,7 +192,7 @@ def scan_backend_callables_ast(functions_dir: Path) -> Tuple[List[str], bool]:
             print(f"[ERROR] AST scan returned invalid JSON: {out}")
             return [], False
     finally:
-        scanner_file.unlink(missing_ok=True)
+        scanner_dest.unlink(missing_ok=True)
 
 def scan_callables() -> Dict[str, Any]:
     """Scan client and backend callables (AST required)"""
diff --git a/tools/go_pipeline.py b/tools/go_pipeline.py
index 4f39d68..d9118b3 100755
--- a/tools/go_pipeline.py
+++ b/tools/go_pipeline.py
@@ -152,11 +152,11 @@ def write_inventory():
     (INV_DIR / 'file_inventory.txt').write_text('\n'.join(files))
 
 def scan_callable_parity():
-    """Check client callable usage vs server exports."""
+    """Check client callable usage vs server exports - BLOCKING."""
     client_callables = set()
     server_callables = set()
     
-    # Scan client (Flutter Customer app)
+    # Scan client (Flutter Customer app + any web-admin if it uses callables)
     if FLUTTER_CUSTOMER_DIR.exists():
         for dart_file in FLUTTER_CUSTOMER_DIR.rglob('*.dart'):
             try:
@@ -168,19 +168,45 @@ def scan_callable_parity():
             except:
                 pass
     
-    # Scan server (Functions) - check index.ts for exports
+    # Scan server (Functions) - comprehensive scan
     if FUNCTIONS_DIR.exists():
         index_file = FUNCTIONS_DIR / 'src' / 'index.ts'
-        if index_file.exists():
+        callables_file = FUNCTIONS_DIR / 'src' / 'callableWrappers.ts'
+        
+        for src_file in [index_file, callables_file]:
+            if not src_file.exists():
+                continue
+            
             try:
-                content = index_file.read_text()
+                content = src_file.read_text()
                 import re
-                # Look for exports.functionName = or export const functionName
-                matches = re.findall(r"exports\.(\w+)\s*=", content)
-                matches2 = re.findall(r"export\s+const\s+(\w+)\s*=", content)
-                server_callables.update(matches)
+                
+                # Pattern 1: export const name =
+                matches1 = re.findall(r"export\s+const\s+(\w+)\s*=", content)
+                server_callables.update(matches1)
+                
+                # Pattern 2: exports.name =
+                matches2 = re.findall(r"exports\.(\w+)\s*=", content)
                 server_callables.update(matches2)
-            except:
+                
+                # Pattern 3: export { name, name2 } from
+                matches3 = re.findall(r"export\s*\{\s*([^}]+)\s*\}\s*from", content)
+                for match in matches3:
+                    names = [n.strip() for n in match.split(',') if n.strip()]
+                    # Handle "name as alias" → extract first part
+                    names = [n.split()[0] if ' ' in n else n for n in names if n]
+                    server_callables.update(names)
+                
+                # Pattern 4: export { name, name2 }
+                matches4 = re.findall(r"export\s*\{\s*([^}]+)\s*\}\s*;", content)
+                for match in matches4:
+                    names = [n.strip() for n in match.split(',') if n.strip()]
+                    # Handle "name as alias" → extract first part
+                    names = [n.split()[0] if ' ' in n else n for n in names if n]
+                    server_callables.update(names)
+                    
+            except Exception as e:
+                print(f"  Warning: Error scanning {src_file}: {e}")
                 pass
     
     parity = {
@@ -188,13 +214,14 @@ def scan_callable_parity():
         'server_exports': sorted(server_callables),
         'missing_on_server': sorted(client_callables - server_callables),
         'unused_on_server': sorted(server_callables - client_callables),
-        'match': client_callables == server_callables or len(client_callables - server_callables) == 0
+        'match': len(client_callables - server_callables) == 0
     }
     
     (EVIDENCE_DIR / 'callable_parity.json').write_text(json.dumps(parity, indent=2))
     
-    # Callable parity is informational only, not blocking for GO_RUN
-    # (builds already passed, so functions exist even if scanner doesn't find them)
+    # BLOCKING: If missing callables, mark as INTERNAL blocker
+    if parity['missing_on_server']:
+        internal_blockers.append(f"Missing server callables: {', '.join(parity['missing_on_server'])}")
     
     return parity
 
@@ -415,6 +442,105 @@ def gate_flutter_merchant():
     
     return True
 
+# =============================================================================
+# GO_SMOKE GATES (Runtime Proof via Emulators)
+# =============================================================================
+
+def gate_smoke_install_deps():
+    """S1: Install smoke test dependencies"""
+    smoke_dir = REPO_ROOT / 'tools' / 'smoke'
+    if not (smoke_dir / 'package.json').exists():
+        gates['S1_smoke_deps'] = {'id': 'S1_smoke_deps', 'rc': 1, 'skipped': True}
+        return True  # Not a blocker if no smoke tests
+    
+    passed, rc, _ = run_cmd('S1_smoke_deps', smoke_dir, 
+                            ['npm', 'install', '--no-audit', '--no-fund'], timeout_sec=180)
+    return passed
+
+def gate_smoke_run():
+    """S2: Run emulators + smoke tests"""
+    smoke_runner = REPO_ROOT / 'tools' / 'smoke' / 'run_emulators.py'
+    if not smoke_runner.exists():
+        gates['S2_smoke_run'] = {'id': 'S2_smoke_run', 'rc': 1, 'skipped': True}
+        external_blockers.append("Smoke tests not available (run_emulators.py missing)")
+        return False
+    
+    # Pre-check: Firebase CLI (external dependency)
+    try:
+        firebase_check = subprocess.run(['which', 'firebase'], capture_output=True, timeout=5)
+        if firebase_check.returncode != 0:
+            gates['S2_smoke_run'] = {'id': 'S2_smoke_run', 'rc': 1, 'skipped': True}
+            external_blockers.append("Firebase CLI not installed (run: npm install -g firebase-tools)")
+            print("\n[GATE] S2_smoke_run")
+            print("  ⏭️  SKIPPED (Firebase CLI not available)")
+            return False
+    except:
+        pass
+    
+    # Pre-check: Java (external dependency)
+    try:
+        java_check = subprocess.run(['which', 'java'], capture_output=True, timeout=5)
+        if java_check.returncode != 0:
+            gates['S2_smoke_run'] = {'id': 'S2_smoke_run', 'rc': 1, 'skipped': True}
+            external_blockers.append("Java not installed (Firestore emulator requires JRE)")
+            print("\n[GATE] S2_smoke_run")
+            print("  ⏭️  SKIPPED (Java not available)")
+            return False
+    except:
+        pass
+    
+    # Set evidence dir for smoke script
+    env = os.environ.copy()
+    env['EVIDENCE_DIR'] = str(EVIDENCE_DIR)
+    
+    print("\n[GATE] S2_smoke_run")
+    try:
+        result = subprocess.run(
+            ['python3', str(smoke_runner)],
+            cwd=REPO_ROOT,
+            capture_output=True,
+            text=True,
+            timeout=300,  # 5 minutes total for emulators + smoke
+            env=env
+        )
+        
+        # Write log
+        (LOGS_DIR / 'S2_smoke_run.log').write_text(f"STDOUT:\n{result.stdout}\n\nSTDERR:\n{result.stderr}")
+        
+        passed = result.returncode == 0
+        gates['S2_smoke_run'] = {
+            'id': 'S2_smoke_run',
+            'rc': result.returncode,
+            'passed': passed,
+            'log': 'logs/S2_smoke_run.log'
+        }
+        
+        if passed:
+            print("  ✅ PASS")
+        else:
+            print(f"  ❌ FAIL (rc {result.returncode})")
+            # Check log for external vs internal failures
+            log_content = result.stdout + result.stderr
+            if 'Firebase CLI not available' in log_content or 'firebase: command not found' in log_content:
+                external_blockers.append("Firebase CLI not installed")
+            elif 'java: command not found' in log_content or 'Java not found' in log_content:
+                external_blockers.append("Java not installed")
+            else:
+                internal_blockers.append("Smoke tests failed")
+        
+        return passed
+        
+    except subprocess.TimeoutExpired:
+        gates['S2_smoke_run'] = {'id': 'S2_smoke_run', 'rc': 124, 'passed': False}
+        internal_blockers.append("Smoke tests timed out")
+        print("  ❌ TIMEOUT")
+        return False
+    except Exception as e:
+        gates['S2_smoke_run'] = {'id': 'S2_smoke_run', 'rc': 127, 'passed': False}
+        external_blockers.append(f"Smoke tests error: {e}")
+        print(f"  ❌ ERROR: {e}")
+        return False
+
 # =============================================================================
 # GO_PROD GATES (Optional)
 # =============================================================================
@@ -454,9 +580,6 @@ def run_go_run_gates():
     # A7: Firestore rules check (runs first, non-blocking for evidence)
     check_firestore_rules()
     
-    # Callable parity check (runs early, non-blocking for evidence)
-    scan_callable_parity()
-    
     # Gate A1-A6 (core build gates)
     if not gate_functions_install():
         return False
@@ -486,6 +609,37 @@ def run_go_run_gates():
     
     return False
 
+def run_go_smoke_gates():
+    """Execute GO_SMOKE gates (runtime proof)."""
+    global level_achieved
+    
+    print("\n" + "="*70)
+    print("EXECUTING GO_SMOKE GATES")
+    print("="*70)
+    
+    # Callable parity check (BLOCKING now)
+    parity = scan_callable_parity()
+    if not parity['match']:
+        return False
+    
+    # Install smoke dependencies
+    if not gate_smoke_install_deps():
+        internal_blockers.append("Smoke dependencies install failed")
+        return False
+    
+    # Run emulators + smoke tests
+    if not gate_smoke_run():
+        return False
+    
+    # Verify smoke report exists
+    smoke_report = EVIDENCE_DIR / 'smoke_report.json'
+    if not smoke_report.exists() or smoke_report.stat().st_size == 0:
+        internal_blockers.append("Smoke report missing or empty")
+        return False
+    
+    level_achieved = 'GO_SMOKE'
+    return True
+
 def run_go_prod_gates():
     """Execute GO_PROD gates (if GO_RUN passed)."""
     global level_achieved
@@ -546,14 +700,28 @@ def main():
     # Execute GO_RUN gates
     go_run_ok = run_go_run_gates()
     
-    # Try GO_PROD if GO_RUN passed and no external blockers
-    if go_run_ok and not external_blockers:
-        run_go_prod_gates()
+    if not go_run_ok:
+        # GO_RUN failed
+        write_final_summary()
+        print_final_verdict()
+        sys.exit(3 if external_blockers else 2)
     
-    # Write final evidence
-    write_final_summary()
+    # GO_RUN passed, attempt GO_SMOKE
+    go_smoke_ok = run_go_smoke_gates()
     
-    # Print final output
+    if not go_smoke_ok:
+        # GO_SMOKE failed, but GO_RUN passed
+        write_final_summary()
+        print_final_verdict()
+        sys.exit(2)  # Internal blocker
+    
+    # GO_SMOKE passed, write evidence and exit
+    write_final_summary()
+    print_final_verdict()
+    sys.exit(0)
+
+def print_final_verdict():
+    """Print final verdict to stdout."""
     print("\n" + "="*70)
     print(f"VERDICT: {'GO' if level_achieved != 'NO-GO' else 'NO-GO'}")
     print(f"LEVEL: {level_achieved}")
@@ -572,14 +740,6 @@ def main():
             print(f"  - {b}")
     
     print("="*70)
-    
-    # Exit code
-    if level_achieved != 'NO-GO':
-        sys.exit(0)
-    elif external_blockers:
-        sys.exit(3)
-    else:
-        sys.exit(2)
 
 if __name__ == '__main__':
     main()
diff --git a/tools/self_heal.py b/tools/self_heal.py
index 62ed1c0..5e31a5d 100755
--- a/tools/self_heal.py
+++ b/tools/self_heal.py
@@ -41,20 +41,27 @@ def analyze_failure(evidence_dir):
     
     fixes = []
     
+    # Check for callable parity failures
+    parity_file = evidence_dir / 'callable_parity.json'
+    if parity_file.exists():
+        parity = json.loads(parity_file.read_text())
+        if not parity.get('match', True) and parity.get('missing_on_server'):
+            fixes.append(('add_callable_wrappers', parity['missing_on_server']))
+    
     for blocker in internal_blockers:
         if 'install failed' in blocker.lower():
             fixes.append(('clean_node_modules', blocker))
-        elif 'missing server callables' in blocker.lower():
-            fixes.append(('add_callables', blocker))
         elif 'firestore.rules' in blocker.lower():
             fixes.append(('create_rules', blocker))
     
     return fixes
+    
+    return fixes
 
 def apply_fixes(fixes):
     """Apply minimal fixes."""
-    for fix_type, blocker in fixes:
-        print(f"\n[FIX] {fix_type}: {blocker}")
+    for fix_type, data in fixes:
+        print(f"\n[FIX] {fix_type}")
         
         if fix_type == 'clean_node_modules':
             # Remove node_modules and retry install
@@ -69,14 +76,11 @@ def apply_fixes(fixes):
                 subprocess.run(['rm', '-rf', str(web_admin_nm)])
                 print(f"  Removed {web_admin_nm}")
         
-        elif fix_type == 'add_callables':
-            # Parse missing callables and add skeleton wrappers
-            # Extract callable names from blocker message
-            import re
-            matches = re.findall(r'Missing server callables: (.+)', blocker)
-            if matches:
-                callables = [c.strip() for c in matches[0].split(',')]
-                add_callable_wrappers(callables)
+        elif fix_type == 'add_callable_wrappers':
+            # data is list of missing callable names
+            missing_callables = data if isinstance(data, list) else []
+            if missing_callables:
+                add_callable_wrappers(missing_callables)
         
         elif fix_type == 'create_rules':
             # Create minimal firestore.rules
@@ -96,27 +100,48 @@ service cloud.firestore {
                 print(f"  Created {rules_file}")
 
 def add_callable_wrappers(callables):
-    """Add missing callable wrappers to callableWrappers.ts."""
+    """Add missing callable wrappers to callableWrappers.ts and index.ts."""
     wrapper_file = REPO_ROOT / 'source' / 'backend' / 'firebase-functions' / 'src' / 'callableWrappers.ts'
+    index_file = REPO_ROOT / 'source' / 'backend' / 'firebase-functions' / 'src' / 'index.ts'
     
     if not wrapper_file.exists():
+        print(f"  ⚠️  callableWrappers.ts not found, skipping")
         return
     
     content = wrapper_file.read_text()
+    index_content = index_file.read_text() if index_file.exists() else ""
     
+    added = []
     for callable_name in callables:
-        if f'exports.{callable_name}' not in content:
-            # Add skeleton wrapper
-            skeleton = f"""
-exports.{callable_name} = functions.https.onCall(async (data, context) => {{
-  // TODO: Implement {callable_name}
-  throw new functions.https.HttpsError('unimplemented', '{callable_name} not implemented');
+        # Check if already exists (either as export const or exports.)
+        if f'export const {callable_name}' in content or f'exports.{callable_name}' in content:
+            print(f"  ⏭️  {callable_name} already exists in wrappers")
+            continue
+        
+        # Add skeleton wrapper (using export const pattern)
+        skeleton = f"""
+export const {callable_name} = functions.https.onCall(async (data, context) => {{
+  // AUTO-GENERATED by self_heal.py - implement properly
+  throw new functions.https.HttpsError('unimplemented', '{callable_name} not yet implemented');
 }});
 """
-            content += skeleton
-            print(f"  Added skeleton wrapper for {callable_name}")
+        content += skeleton
+        added.append(callable_name)
+        print(f"  ✅ Added skeleton wrapper for {callable_name}")
+    
+    if added:
+        wrapper_file.write_text(content)
+        
+        # Ensure exports in index.ts
+        if index_file.exists():
+            export_block = f"export {{ {', '.join(added)} }} from './callableWrappers';\n"
+            if export_block not in index_content:
+                # Append to end of file
+                index_content += f"\n// Auto-added by self_heal.py\n{export_block}"
+                index_file.write_text(index_content)
+                print(f"  ✅ Added exports to index.ts: {', '.join(added)}")
     
-    wrapper_file.write_text(content)
+    print(f"  Total wrappers added: {len(added)}")
 
 def main():
     """Main self-heal loop."""
